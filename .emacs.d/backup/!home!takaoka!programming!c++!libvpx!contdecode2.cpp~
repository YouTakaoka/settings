#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<vpx/vpx_decoder.h>
#include<vpx/vpx_codec.h>
#include<vpx/vp8.h>
#include "include/tools_common.h"
#include<opencv2/opencv.hpp>
#include<opencv2/videoio.hpp>
#include<iostream>

using namespace std;

#define MAX_PACS 10  // max number of packets
#define END "###end###"  // ending string of packet
#define LENGTH_OF_RTP_HEADER 12 // length of rtp header
#define LENGTH_OF_PD 4  // length of payload discriptor
#define LENGTH_OF_PH 3  // length of payload header
#define DISP_PIC 0     // whether display pictures on GUI window or not

typedef struct Packet{
  int len;
  char data[10000];
} Packet;

void save_frame(void* arg, const vpx_image_t* image);
int readUntil(FILE* fp, char* buf, char str[], const int max);
void usage_exit();
int sflag(Packet* packet);
void writeImageAsBMP(vpx_image_t* img, char name[]);
void dispImage(vpx_image_t* img, char window[]);
void dispPlane(uchar* plane, int w, int h, char* window);
int getMbit(char* header);
int getPID(char* pd);
int getSbit(char* pd);
int readFrame(FILE* fp, char* buf, char str[], int max);
cv::Mat imageToMat(vpx_image_t* img);

/* args: inputfile */
int main(int argc, char* argv[]){
  int len;
  int frame_count;
  char* frame;
  vpx_image_t* img;
  char window_y[] = "y";  // window name
  char window_u[] = "u";
  char window_v[] = "v";  
  const VpxInterface* decoder; // Decoder
  vp8_postproc_cfg_t pp = {VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE, 0, 0};  // Postprocessing

  if(argc != 2){ // argument validation
    usage_exit();
  }
  char* infname;  // the first argument: input file name
  infname = argv[1];

  // Initialize video writer
  cv::VideoWriter writer("out.avi", cv::VideoWriter::fourcc('M','J','P','G'), 30.0, cv::Size(704,544), true);
  if(!writer.isOpened()){
    cerr << "Failed to initialize video writer." << endl;
    return 1;
  }
  
  // Open input file
  FILE* infile = fopen(infname, "r");
  if(infile == NULL){
    fprintf(stderr,"Failed to open input file.\n");
    return 1;
  }

  // Create context
  decoder = get_vpx_decoder_by_name("vp8");
  vpx_codec_ctx_t codec;  // Context

  // Initialize context
  int status;
  status = vpx_codec_dec_init(&codec, decoder->codec_interface(), NULL, VPX_CODEC_USE_POSTPROC);
  if(status == VPX_CODEC_INCAPABLE){
    cerr << "Postprocessing is incapable for this codec." << endl;
    goto destroy_ctx;
  } else if(status != VPX_CODEC_OK){
    fprintf(stderr,"Failed to initialize context: %d\n", status);
    goto destroy_ctx;
  }

  // // Postprocessing configuration
  // if(vpx_codec_control(&codec, VP8_SET_POSTPROC, &pp)){
  //   fprintf(stderr, "Failed to turn on postproc.\n");
  // }

  if(DISP_PIC){
    // windows to show images
    cv::namedWindow(window_y, CV_WINDOW_AUTOSIZE);
    cv::namedWindow(window_u, CV_WINDOW_AUTOSIZE);
    cv::namedWindow(window_v, CV_WINDOW_AUTOSIZE);
  }

  /* Now we come to the main loop */
  Packet packet[MAX_PACS];
  frame = (char*)malloc(10000*MAX_PACS);
  img = (vpx_image_t*)malloc(1000000);  // Allocate memory for raw image data
  frame_count = 0;
  len = 0;
    
  while((len = readFrame(infile, frame, END, 100000))>0){
    cout << "Read " << frame_count << "-th frame. Size = " << len << endl;
    
    // Decode
    printf("Start decoding\n");
    vpx_codec_iter_t iter = NULL;

    status = vpx_codec_decode(&codec, (uint8_t*)frame, len, NULL, 0);

    if(status != VPX_CODEC_OK){
      printf("Failed to decode: %d\n", status);
      goto free_mems;
    }

    printf("Get frame\n");
    while((img = vpx_codec_get_frame(&codec, &iter)) != NULL){
      printf("fmt=%d, cs=%d, color_range=%d\n", img->fmt, img->cs, img->range);
      printf("w=%d, h=%d\n", img->w, img->h);
      printf("bit depth=%d\n",img->bit_depth);
      if(img->fmt == VPX_IMG_FMT_I420)
        printf("Image format is I420\n");

      writer << imageToMat(img);
      
      // // Write image into file
      // if(frame_count < 20){
      //   char name[20];
      //   sprintf(name, "image%d.bmp", frame_count);
      //   writeImageAsBMP(img, name);
      // }

      if(DISP_PIC){
        /* Display images */
        dispPlane(img->planes[VPX_PLANE_Y], img->w, img->h, window_y);
        dispPlane(img->planes[VPX_PLANE_U], img->w/2, img->h/2, window_u);
        dispPlane(img->planes[VPX_PLANE_V], img->w/2, img->h/2, window_v);
      }
        
      /* Write YUV data into file */
      // fwrite(img->planes[0], 1, img->h*img->w, outfile);
        
      frame_count++;
    }
  }

  printf("Processed %d frames.\n", frame_count);
  
  
 free_mems:
  // Free memory
  free(frame);
  free(img);
  
  //fclose(outfile);  // Close output file

 destroy_ctx:  
  // Destroy context
  status = vpx_codec_destroy(&codec);
  if(status != VPX_CODEC_OK){
    fprintf(stderr,"Failed to destroy context: %d\n", status);
  }

 close_files:
  fclose(infile); // Close input file
  printf("Input and output file closed.\n");

  if(DISP_PIC)
    cv::waitKey();
  
  return 0;
}

void usage_exit(){
  printf("usage: contdecode inputfile\n");
  exit(1);
}

void dispImage(vpx_image_t* img, char window[]){
  cv::Mat mBGR;
  cv::Mat mYUV(img->h*3/2, img->w, CV_8UC1, img->img_data);
  cv::cvtColor(mYUV, mBGR, CV_YUV2BGR_I420);
  cv::imshow(window, mBGR);
}

void dispPlane(uchar* plane, int w, int h, char* window){
  cv::Mat mat(h,w, CV_8UC1, plane);
  cv::imshow(window, mat);
}

cv::Mat imageToMat(vpx_image_t* img){
  cv::Mat mBGR;
  cv::Mat mYUV(img->h*3/2, img->w, CV_8UC1, img->img_data);
  cv::cvtColor(mYUV, mBGR, CV_YUV2BGR_I420);
  return mBGR;
}

void writeImageAsBMP(vpx_image_t* img, char name[]){
  cv::Mat mBGR = imageToMat(img);

  cv::imwrite(name, mBGR);
  cout << "Image wrote." << endl;
}

/**
* Read from file pointer fp into buffer buf until string str appears
* @ret length of the string (-1 if the string not found or reached to max)
*/
int readUntil(FILE* fp, char* buf, char str[], const int max){
  int l;
  int sl = strlen(str);
  
  for(l=0; fread(buf+l, 1, 1, fp)>0 && l<max; l++){
    if(l+1 >= sl && memcmp(buf+l-sl+1, str, sl)==0){
      return l-sl+1;
    }
  }

  return -1;
}

int getMbit(char* header){
  return (header[1]>>7)&1;
}

int getSbit(char* pd){
  return (pd[0]>>4)&1;
}

int getPID(char* pd){
  return pd[0] & 0b111;
}

int readFrame(FILE* fp, char* buf, char str[], int max){
  int l, len=0;
  char* tmp0 = (char*)malloc(10000);
  char* tmp = tmp0;
  
  /* If M-bit is 1, it is the last packet of the frame */
  while((l = readUntil(fp, tmp, str, max)) > 0){
    int mbit = getMbit(tmp);
    
    //Remove the RTP header
    tmp += LENGTH_OF_RTP_HEADER;
    l -= LENGTH_OF_RTP_HEADER;

    // Remove PD. Note that we must not remove the payload header.
    tmp += LENGTH_OF_PD;
    l -= LENGTH_OF_PD;

    //Append the depacketized paylaod at the end of the frame buffer
    memcpy(buf+len, tmp, l);
    len += l;

    tmp = tmp0;
    
    if(mbit == 1)
      break;
  }
  free(tmp0);

  if(l<=0){
    cout << "*** Reading error or reached EOF ***" << endl;
    cout << "len = " << len << endl;
    return -1;
  }
  
  return len;
}

