#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<vpx/vpx_decoder.h>
#include<vpx/vpx_codec.h>
#include<vpx/vp8.h>
#include "include/tools_common.h"
#include<opencv2/opencv.hpp>
#include<iostream>

using namespace std;

#define MAX_PACS 10
#define END "###end###"

typedef struct Packet{
  int len;
  char data[10000];
} Packet;

void save_frame(void* arg, const vpx_image_t* image);
int readUntil(FILE* fp, char* buf, char str[], const int max);
void usage_exit();
int sflag(Packet* packet);
void writeImageAsBMP(vpx_image_t* img, char name[]);
void dispImage(vpx_image_t* img, char window[]);
cv::Mat I420toBGR(uchar* pY, uchar* pU, uchar* pV, int height, int width);
void dispPlane(uchar* plane, int w, int h, char* window);

/* args: inputfile */
int main(int argc, char* argv[]){
  int cnt;
  int frame_count;
  char* frame;
  vpx_image_t* img;
  char window_y[] = "y";  // window name
  char window_u[] = "u";
  char window_v[] = "v";  
  char outfn[] = "out.yuv";  // output file for debug
  const VpxInterface* decoder; // Decoder
  vp8_postproc_cfg_t pp = {VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE, 0, 0};  // Postprocessing
  
  if(argc != 2){ // argument validation
    usage_exit();
  }
  char* infname;  // the first argument: input file name
  infname = argv[1];

  // Open input file
  FILE* infile = fopen(infname, "r");
  if(infile == NULL){
    fprintf(stderr,"Failed to open input file.\n");
    return 1;
  }

  // Open output file
  FILE* outfile = fopen(outfn, "w");
  if(outfile == NULL){
    fprintf(stderr,"Failed to open output file.\n");
    goto close_files;
  }

  // Create context
  decoder = get_vpx_decoder_by_name("vp8");
  vpx_codec_ctx_t codec;  // Context

  // Initialize context
  int status;
  status = vpx_codec_dec_init(&codec, decoder->codec_interface(), NULL, VPX_CODEC_USE_POSTPROC);
  if(status == VPX_CODEC_INCAPABLE){
    cerr << "Postprocessing is incapable for this codec." << endl;
    goto destroy_ctx;
  } else if(status != VPX_CODEC_OK){
    fprintf(stderr,"Failed to initialize context: %d\n", status);
    goto destroy_ctx;
  }

  // Postprocessing configuration
  if(vpx_codec_control(&codec, VP8_SET_POSTPROC, &pp)){
    fprintf(stderr, "Failed to turn on postproc.\n");
  }


  /* Now we come to the main loop */
  Packet packet[MAX_PACS];
  cnt = 0;
  frame = (char*)malloc(10000*MAX_PACS);
  img = (vpx_image_t*)malloc(1000000);  // Allocate memory for raw image data
  frame_count = 0;
  cv::namedWindow(window_y, CV_WINDOW_AUTOSIZE);  // window to show images
  cv::namedWindow(window_u, CV_WINDOW_AUTOSIZE);  // window to show images
  cv::namedWindow(window_v, CV_WINDOW_AUTOSIZE);  // window to show images
    
  do{
    // Read coded frame
    printf("Start reading packets.\n");
    while((packet[cnt].len = readUntil(infile, packet[cnt].data, END, 10000)) > 0 && sflag(&packet[cnt]) == 0){
      cnt++;
    }
    printf("Read %d packets.\n", cnt);

    // Unify the packets into single frame data
    int len=0;
    for(int j=0; j<cnt; j++){
      memcpy(frame+len, packet[j].data+4, packet[j].len-4);
      len += packet[j].len;
    }

    if(len>0){
      // Decode
      printf("Start decoding\n");
      vpx_codec_iter_t iter = NULL;

      status = vpx_codec_decode(&codec, (uint8_t*)frame, len, NULL, 0);

      if(status != VPX_CODEC_OK){
        printf("Failed to decode: %d\n", status);
        goto free_mems;
      }

      printf("Get frame\n");
      while((img = vpx_codec_get_frame(&codec, &iter)) != NULL){
        printf("fmt=%d, cs=%d, color_range=%d\n", img->fmt, img->cs, img->range);
        printf("w=%d, h=%d\n", img->w, img->h);
        printf("bit depth=%d\n",img->bit_depth);
        if(img->fmt == VPX_IMG_FMT_I420)
          printf("Image format is I420\n");
        
        // Write image into file
        if(frame_count < 20){
          char name[20];
          sprintf(name, "image%d.bmp", frame_count);
          writeImageAsBMP(img, name);
        }

        /* Display images */
        dispPlane(img->planes[VPX_PLANE_Y], img->w, img->h, window_y);
        dispPlane(img->planes[VPX_PLANE_U], img->w/2, img->h/2, window_u);
        dispPlane(img->planes[VPX_PLANE_V], img->w/2, img->h/2, window_v);
        
        /* Write YUV data into file */
        // fwrite(img->planes[0], 1, img->h*img->w, outfile);
        
        frame_count++;
      }
    }

    packet[0] = packet[cnt];
    cnt = 1;
    
  }while(packet[0].len > 0);

  printf("Processed %d frames.\n", frame_count);
  
  
 free_mems:
  // Free memory
  free(frame);
  free(img);
  
  //fclose(outfile);  // Close output file

 destroy_ctx:  
  // Destroy context
  status = vpx_codec_destroy(&codec);
  if(status != VPX_CODEC_OK){
    fprintf(stderr,"Failed to destroy context: %d\n", status);
  }

 close_files:
  fclose(infile); // Close input file
  fclose(outfile); // close output file
  printf("Input and output file closed.\n");

  cv::waitKey();
  
  return 0;
}

void usage_exit(){
  printf("usage: contdecode inputfile\n");
  exit(1);
}

void dispImage(vpx_image_t* img, char window[]){
  int conv_mtd=1;
  cv::Mat mBGR;
  if(conv_mtd == 0){
    mBGR = I420toBGR(img->planes[VPX_PLANE_Y], img->planes[VPX_PLANE_U],img->planes[VPX_PLANE_V], img->h, img->w);
  } else {
    cv::Mat mYUV(img->h*3/2, img->w, CV_8UC1, img->img_data);
    cv::cvtColor(mYUV, mBGR, CV_YUV2BGR_I420);
  }
  cv::imshow(window, mBGR);
}

void dispPlane(uchar* plane, int w, int h, char* window){
  cv::Mat mat(h,w, CV_8UC1, plane);
  cv::imshow(window, mat);
}

void writeImageAsBMP(vpx_image_t* img, char name[]){
  int conv_mtd=1;
  cv::Mat mBGR;
  if(conv_mtd == 0){
    mBGR = I420toBGR(img->planes[VPX_PLANE_Y], img->planes[VPX_PLANE_U],img->planes[VPX_PLANE_V], img->h, img->w);
  } else {
    cv::Mat mYUV(img->h*3/2, img->w, CV_8UC1, img->img_data);
    cv::cvtColor(mYUV, mBGR, CV_YUV2BGR_I420);
  }
  cv::imwrite(name, mBGR);
  cout << "Image wrote." << endl;
}

/**
* Read from file pointer fp into buffer buf until string str appears
* @ret length of the string (-1 if the string not found or reached to max)
*/
int readUntil(FILE* fp, char* buf, char str[], const int max){
  int l;
  int sl = strlen(str);
  
  for(l=0; fread(buf+l, 1, 1, fp)>0 && l<max; l++){
    if(l+1 >= sl && memcmp(buf+l-sl+1, str, sl)==0){
      return l-sl+1;
    }
  }

  return -1;
}


int sflag(Packet* packet){
  char h = *packet->data;
  int s = (h>>4) & 1;
  return s;
}

// left upper, right upper, left bottom, right bottom, namely, of the block
enum{
  LU=0,
  RU=1,
  LB=2,
  RB=3 
};

cv::Mat I420toBGR(uchar* pY, uchar* pU, uchar* pV, int height, int width){
    cv::Mat result(height,width,CV_8UC3);
    uchar y,cb,cr;

    long ySize=width*height;
    long uSize;
    uSize=ySize>>2;

    uchar *output;

    uchar r,g,b;
    for (int i=0;i<uSize;++i){
      int npix[4]; // address of each pixel in the block
      npix[LU] = 4*(i/(width/2))*width/2 + 2*(i%(width/2));
      npix[RU] = npix[LU] + 1;
      npix[LB] = npix[LU] + width;
      npix[RB] = npix[LB] + 1;
        
      for(int j=0;j<4;++j){
        output = result.data + 3*npix[j];

        y=pY[i*4+j];
        cb=pU[i];
        cr=pV[i];

        //ITU-R standard
        // b=cv::saturate_cast<uchar>(y+1.772*(cb-128));
        // g=cv::saturate_cast<uchar>(y-0.344*(cb-128)-0.714*(cr-128));
        // r=cv::saturate_cast<uchar>(y+1.402*(cr-128));

        b=cv::saturate_cast<uchar>(1.164*(y-16)+2.018*(cb-128));
        g=cv::saturate_cast<uchar>(1.164*(y-16)-0.391*(cb-128)-0.813*(cr-128));
        r=cv::saturate_cast<uchar>(1.164*(y-16)+1.596*(cr-128));

        output[0] = b;
        output[1] = g;
        output[2] = r;
      }
    }
    return result;
}

