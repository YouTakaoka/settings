/** TODO
 * - kill the thread after sending the last packet
 * - if got EOT(End Of Talk) signal from the client, tell it to the Java module
 * - mutex
 */

#include<stdlib.h>
#include<gmodule.h>

#define TALK_INTERVAL 100   // interval of data sending in the talk thread(ms)

typedef struct janus_echotest_text_packet{
  unsigned short talk_num;  // talk sequence number
  unsigned long long timestamp;
  char data[64];  // Except for header
} janus_echotest_text_packet;

typedef struct janus_echotest_audio_packet{
  unsigned short talk_num;  // talk sequence number
  unsigned long long timestamp;
  char data[640];  // Except for header
  int len;
} janus_echotest_audio_packet;

struct janus_echotest_session{
  //Additional entries
  unsigned short talk_num;     // sequence number of current talk
  int talkthread_running;      // 1:running  0:not running
  GSList* packets;              //buffer of audio packets
  GSList* datas[64];            //buffer of data packets
};

void janus_echotest_create_session(janus_plugin_session *handle, int *error) {
  //initialize variables
  session->talk_num = 0;
  session->talkthread_running = 0;
  session->packets = NULL;
  session->datas = NULL;
}

void janus_echotest_destroy_session(janus_plugin_session *handle, int *error) {
  g_slist_free_full(session->packets, free);
  g_slist_free(session->datas);
}

void janus_echotest_text_listener(){
  //got buf(null terminate)
  //Split the input data and make packet
  char* temp;
  janus_echotest_text_packet packet;
  temp = strtok(buf, ":");
  packet->talk_num = atoi(temp);   // get sequence number
  temp = temp + strlen(temp) + 2;
  strcpy(packet->data, temp);
  temp = strtok(NULL, ":");
  if(!strcmp(temp, "finish")){
    //we got "finish."
    continue;
  }
  temp = strtok(NULL, ":");
  packet->timestamp = atoi(temp);

  if(packet->talk > session->talk_num && !session->talkthread_running){
    //Start new talk thread
    session->talkthread_running = 1;
    session->talk_num = talk;
    start(talk_thread);
  }

  //push data to the list
  janus_echotest_text_packet* packet_ptr = (janus_echotest_text_packet*)malloc(sizeof(janus_echotest_text_packet));
  g_slist_append(session->datas, packet_ptr);
}

void janus_echotest_aduio_listener(){
  //got buf, len

  // Make audio packet data
  janus_echotest_audio_packet packet;
  packet->talk_num = *((unsigned short*)buf);
  packet->timestamp = *((unsgned long long*)(buf+2));
  memcpy(packet->data, buf+10, len-10);
  packet->len = len-10;
  
  if(packet->talk_num > session->talk_num && !session->talkthread_running){
    //Start new talk thread
    session->talkthread_running = 1;
    session->talk_num = talk;
    start(talk_thread);
  }

  //push packet to the list
  janus_echotest_audio_packet* packet_ptr = (janus_echotest_audio_packet*)malloc(sizeof(janus_echotest_audio_packet));
  *packet_ptr = packet;
  g_slist_append(session->packets, packet_ptr);
}

void talk_thread(){
  unsigned long long time_to_send = 0;  // If the timestamp is before this time, send data.
  
  while(session->talkthread_running){
    /* Send audio packets whose timestamps are before time_to_send */
    janus_echotest_audio_packet* packet;
    while((packet = g_slist_nth_data(session->packets, 0)) != NULL){
      unsigned long long ts = packet->timestamp;
      
      if(ts < time_to_send){
        janus_echotest_sendback_audio(session->handle, packet->data, packet->len);
        session->packets = g_slist_remove(session->packets, packet);
        free(packet);
      }
    }

    /* Send text data whose timestamp is before time_to_send */
    char data[64];
    while((packet = g_slist_nth_data(session->datas, 0)) != NULL){
      unsigned long long ts = packet->timestamp;
      char data[] = packet->data;
      
      if(ts < time_to_send){
        janus_echotest_sendback_audio(session, data, strlen(data));
        session->datas = g_slist_remove(session->datas, data);
      }
    }

    time_to_send += TALK_INTERVAL;
    sleep(TALK_INTERVAL);
  }
  
}

